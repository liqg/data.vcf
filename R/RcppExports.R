## Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Resize a list of string vectors by a number vector with a same length with the list.
#' The elements of x[i] after n[i] will be discarded, 
#' however, if the length of x[i] is less than n[i], the 'fill' string will be added in the end.
#' @param x a list of string vectors.
#' @param n a number vector.
#' @param fill default value for expanded vector.
#' @return a resized list will be return.
resize_list_string <- function(x, n, fill = "") {
    .Call('_data_vcf_resize_list_string', PACKAGE = 'data.vcf', x, n, fill)
}

#' Split a str by sep into ikv list.
#' @param x a string vector
#' @return An list of {i, k, v}
#'
str_to_ikv <- function(x, sep) {
    .Call('_data_vcf_str_to_ikv', PACKAGE = 'data.vcf', x, sep)
}

#' collapse each vector of a list by a group of indexs
#' @param x list
#' @param g list
#' @param sep string
#' @param fill string
#' @return list
#'
collapse_group <- function(x, g, sep = "", fill = "") {
    .Call('_data_vcf_collapse_group', PACKAGE = 'data.vcf', x, g, sep, fill)
}

#' remove consecutive duplicate characters in a string
#' 
uniq_char <- function(x, y = "") {
    .Call('_data_vcf_uniq_char', PACKAGE = 'data.vcf', x, y)
}

kvpaste_rcpp <- function(input, sep1, sep2, nakey) {
    .Call('_data_vcf_kvpaste_rcpp', PACKAGE = 'data.vcf', input, sep1, sep2, nakey)
}

count_beyond_threshold <- function(x, y) {
    .Call('_data_vcf_count_beyond_threshold', PACKAGE = 'data.vcf', x, y)
}

kvsplit_rcpp <- function(input, sep1, sep2, na) {
    .Call('_data_vcf_kvsplit_rcpp', PACKAGE = 'data.vcf', input, sep1, sep2, na)
}

col_sums <- function(m, rows_list) {
    .Call('_data_vcf_col_sums', PACKAGE = 'data.vcf', m, rows_list)
}

col_maxs <- function(m, rows_list) {
    .Call('_data_vcf_col_maxs', PACKAGE = 'data.vcf', m, rows_list)
}

#' open a vcf file
#' @param path the path for vcf file
#' @return a reader object for vcf reading
open_file_rcpp <- function(path) {
    .Call('_data_vcf_open_file_rcpp', PACKAGE = 'data.vcf', path)
}

#' read n lines from the file.
#' @param reader a pointer returned by open_vcf.
#' @param n how many lines to read default: n=0 for file end
#' @return a character vector, return a empty vector (length=0) when reading a file that had reached EOF; return a vector of length 1 with "" for blank line.
read_lines <- function(reader, n) {
    .Call('_data_vcf_read_lines', PACKAGE = 'data.vcf', reader, n)
}

read_vcf_header <- function(reader) {
    .Call('_data_vcf_read_vcf_header', PACKAGE = 'data.vcf', reader)
}

split_var_lines_rcpp <- function(lines, info_keys, format_keys, sample_ids, break_alt, break_info_keys, break_format_keys, info_keys_exclude, format_keys_exclude) {
    .Call('_data_vcf_split_var_lines_rcpp', PACKAGE = 'data.vcf', lines, info_keys, format_keys, sample_ids, break_alt, break_info_keys, break_format_keys, info_keys_exclude, format_keys_exclude)
}

split_format_rcpp <- function(format, samples) {
    .Call('_data_vcf_split_format_rcpp', PACKAGE = 'data.vcf', format, samples)
}

vcf_breakalt_rcpp <- function(vcf, ovcf, info_keys, format_keys) {
    invisible(.Call('_data_vcf_vcf_breakalt_rcpp', PACKAGE = 'data.vcf', vcf, ovcf, info_keys, format_keys))
}

vcf_clean_rcpp <- function(vcf, ovcf, info_keys, format_keys) {
    invisible(.Call('_data_vcf_vcf_clean_rcpp', PACKAGE = 'data.vcf', vcf, ovcf, info_keys, format_keys))
}

